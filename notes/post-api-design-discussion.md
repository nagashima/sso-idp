# POST系API設計の検討事項

## 前提：当初の構想

- **POST /api/v1/users**: 全カラム指定でUpsert（Update or Insert）
- **PATCH /api/v1/users/:id**: 対象カラムのみ指定でUpdate

---

## 検討の経緯

### 問題の所在

PATCH /api/v1/users/:id は問題なし：
- ID指定必須で対象を特定
- 差分のみ更新

POST /api/v1/users の挙動が要検討：
- **ID指定あり** → Update目的が自明、レコード不在時の挙動を決める必要
- **ID指定なし** → 新規登録の意図、以下2点を決める必要：
  1. 既存レコード判定方法（email? phone? 両方? 判定しない?）
  2. 既存レコードがあった場合の処理（更新? エラー? 新規作成?）

### RP側の利用文脈

RPからのAPI操作は「**代理登録者によるユーザーの代理登録**」：
- 病院の受付スタッフが患者情報を登録
- 企業の人事部が従業員情報を登録
- WEBフォームで入力した情報をIdPへAPI送信

### Upsert（自動更新）の問題点

ID未指定時に既存レコードを自動更新すると：

```
代理登録者が「新規登録」画面で入力
↓
POST /api/v1/users（ID未指定）を送信
↓
emailが一致する既存レコードが自動更新されてしまう
↓
代理登録者は「新規登録した」と思い込んでいる
↓
問題発生:
- 既存データが意図せず上書き（データ破損リスク）
- RP側DBとIdPの紐付けが不整合
- 他RPが作成したユーザーを勝手に更新してしまう
```

### 一般的なDB操作との整合性

- **ID未指定のINSERT** → 新規登録の意図（AUTO_INCREMENT）
- **ユニーク制約違反** → SQLエラー
- **WEB登録** → 登録済みメールアドレスは「使用済み」エラー

ID指定ありで存在しないIDを指定 → エラー（厳格）
ID指定なしでユニーク制約違反 → エラー（厳格）

という一貫した考え方。

---

## 暫定案

### API仕様

```
PATCH /api/v1/users/:id （部分更新）
- ID指定必須
- レコード存在 → 部分更新（200 OK）
- レコード不在 → 404 Not Found

POST /api/v1/users （ID指定あり）
- Update目的が自明
- レコード存在 → 全体更新（200 OK）
- レコード不在 → 404 Not Found

POST /api/v1/users （ID未指定）
- 常に新規作成（INSERT）
- 成功 → 201 Created
- email/phone重複 → 409 Conflict（明示的エラー）
```

### 暫定案を選んだ理由

#### 1. 意図しない上書きを防ぐ

代理登録者が「新規登録」のつもりで操作している場合、既存レコードを更新してしまうのは好ましくない。

#### 2. 明示的なエラー通知

```
代理登録者が「新規登録」画面で入力
↓
POST /api/v1/users（ID未指定）を送信
↓
409 Conflict「このメールアドレス/電話番号は既に登録されています」
↓
代理登録者：「既に存在するユーザーだ」
↓
適切な対応:
- 既存ユーザーを検索して更新
- または本人に確認
- ログイン画面へ誘導してSSO認証 → RP側DBに紐付け
```

#### 3. WEB登録との一貫性

ユーザー自身がWEBで登録する場合と同じUX。

#### 4. 設計の一貫性

| 操作 | ID指定 | 挙動 |
|------|--------|------|
| POST | あり | 存在チェック → 不在なら404（厳格） |
| POST | なし | ユニーク制約チェック → 重複なら409（厳格） |
| PATCH | 必須 | 存在チェック → 不在なら404（厳格） |

**共通思想**: 不在/重複時は明示的エラーを返し、クライアント側で判断

#### 5. セキュリティ

他RPが作成したユーザーを勝手に更新しない。

---

## 検討した選択肢と比較

### POST時のID指定ありの挙動

| 案 | 挙動 | メリット | デメリット |
|---|------|---------|----------|
| A案（厳格）✅ | ID不在 → 404エラー | 更新意図が明確なのにレコード不在は異常として扱える | - |
| B案（柔軟） | ID不在 → IDを無視して新規作成 | 柔軟 | 意図しない動作、混乱の元 |

### POST時のID指定なしの挙動

| 案 | 挙動 | メリット | デメリット |
|---|------|---------|----------|
| A案（常に新規）✅ | email重複 → 409エラー | シンプル、安全、WEB登録と一貫性 | RPが事前にGET必要（「このemailを最新化」の場合） |
| B案（email判定） | emailで既存検索 → Upsert | RPが事前にGET不要 | 意図しない上書き、代理登録者が混乱 |
| C案（phone判定） | phone_numberで既存検索 → Upsert | RPが事前にGET不要 | 意図しない上書き、代理登録者が混乱 |
| D案（専用キー） | lookup_byで判定カラムを指定 | 柔軟 | API複雑化 |
| E案（両方判定） | emailとphoneの両方で判定 → Upsert | 柔軟 | 複数ヒット時の処理が複雑、意図しない上書き |

---

## RP側の実装イメージ

### 既存ユーザー更新フロー

```
1. RP画面で一覧から選択 → IDが分かっている
2. WEBフォームで編集
3. PATCH /api/v1/users/:id または POST /api/v1/users（ID指定）
4. 404エラー → 「ユーザーが見つかりません」表示（異常系）
```

- **基本的に404は出ない**（RP側DBに存在するIDを使用）
- 出るとすればIdP側で削除済みなどの異常系

### 新規ユーザー登録フロー

```
1. RP画面で「新規登録」
2. WEBフォームで入力
3. POST /api/v1/users（ID未指定）
4. 409 Conflictエラー → 「このメールアドレスは既に登録されています」表示
   → ログイン画面へ誘導
   → SSO認証
   → RP側DBにuser_idを紐付け
```

- **409は現実的に発生しうる**
  - 別のRPが既に同じemailで登録済み
  - ユーザー自身がSSO/WEBで既に登録済み

---

## 懸念点・要確認事項（チームで議論すべき点）

### 1. RPが「このemailの情報を最新化したい」ケース

暫定案では、RPが事前にGETして既存ユーザーのIDを取得する必要がある。

```
GET /api/v1/users?email=user@example.com
↓
ID取得
↓
PATCH /api/v1/users/:id または POST /api/v1/users（ID指定）
```

**懸念**: 2ステップになる
**反論**: 明示的で安全、代理登録の文脈では許容範囲

### 2. セキュリティ面の追加検討

- 現状の暫定案では、created_byのチェックなし
- 必要に応じて、他RPが作成したユーザーの更新を制限する仕組み

### 3. トランザクション境界

- 同時リクエストで同じemailのPOSTが2件来た場合
- Race conditionでユニーク制約違反の可能性
- **対応**: DB側のユニーク制約で保護（現状で問題なし）

### 4. レスポンス仕様

- 新規作成: 201 Created
- 更新: 200 OK
- レスポンスボディに作成/更新の情報を含めるかは実装時に検討

---

## 補足：created_by / updated_by の設定

- **新規作成時（POST ID未指定）**: `created_by` にリクエスト元RPのIDを設定
- **更新時（POST ID指定 / PATCH）**: `updated_by` にリクエスト元RPのIDを設定
- **WEB/SSO登録**: どちらもNULL

---

## 次のステップ

1. ✅ 暫定案策定（本ドキュメント）
2. 実装: `app/controllers/api/v1/users_controller.rb`（暫定案ベース）
3. チームへ情報共有
   - 暫定案の説明
   - 理由と検討経緯
   - 懸念点の提示
4. フィードバック反映 → 必要に応じて調整
5. テスト: `spec/requests/api/v1/users_spec.rb`

---

## 参考：一般的なパターン

### 1. 厳格なRESTful（従来型）

```
POST /users         → 新規のみ、存在すればエラー（409 Conflict）
PUT /users/:id      → 全体更新、全カラム必須
PATCH /users/:id    → 部分更新、差分のみ
```

**特徴：**
- クライアントが事前にGETして存在確認し、POST/PUT/PATCHを使い分ける必要がある
- 厳格だが、クライアント側の実装負担が大きい

### 2. Upsert（現代的）

```
POST /users         → なければ作成、あれば更新（全カラム）
PATCH /users/:id    → 部分更新（差分のみ）
```

**特徴：**
- RPが楽、一般的になってきている
- 事前のGETが不要
- 意図しない上書きのリスク

### 3. 本プロジェクトの暫定案（厳格寄り）

```
POST /users         → ID指定あり: 更新、ID指定なし: 新規のみ（重複は409）
PATCH /users/:id    → 部分更新（差分のみ）
```

**特徴：**
- 厳格なRESTfulとUpsertの中間
- 代理登録の文脈で安全性を重視
